@page "/teacher/add-question"
@page "/teacher/edit-question/{questionId:int?}"

@using BlazingQuiz.Shared
@using BlazingQuiz.Shared.DTOs
@using Microsoft.AspNetCore.Authorization
@attribute [Authorize(Roles = nameof(UserRole.Teacher))]

@inject NavigationManager NavigationManager
@inject IQuizApi QuizApi
@inject IJSRuntime JsRuntime
@inject IAppState AppState
@inject QuestionImageService QuestionImageService
@inject QuestionAudioService QuestionAudioService

<EditForm Model="_questions[0]"> @* Using first question as main model for validation *@
    <DataAnnotationsValidator />

    <!-- Slider Container -->
    <div class="slider-container">
        <div class="slider-track" style="transform: translateX(@(CurrentCardIndex * -100)%);">
            @for (int i = 0; i < _questions.Count; i++)
            {
                var question = _questions[i];
                var questionIndex = i;

                <div class="slider-card">
                    <div class="card-header-3d d-flex justify-content-between align-items-center">
                        <h4 class="m-0">Question @(i + 1)</h4>
                        @if (_questions.Count > 1)
                        {
                            <button type="button" class="btn btn-3d btn-3d-danger btn-sm" @onclick="() => DeleteQuestionAsync(question)" title="Delete Question" style="padding: 0.25rem 0.5rem; font-size: 0.875rem;">
                                <span class="material-symbols-outlined" style="font-size: 1rem;">
                                    delete
                                </span>
                            </button>
                        }
                    </div>

                    <div class="question-card-content">
                        <div class="row">
                            <!-- Left side: Question Text -->
                            <div class="col-md-6 border-end">
                                <div class="mb-3">
                                    <label class="form-label">Question Text</label>
                                    <textarea @bind="question.Text" class="form-control form-control-centered" rows="3" style="font-size: 1.1rem; letter-spacing: 0.1rem;"></textarea>
                                    <ValidationMessage For="() => question.Text" />
                                </div>

                                <!-- Question Image and Audio on the same row -->
                                <div class="row">
                                    <!-- Question Image Upload Section -->
                                    <div class="col-md-6 mb-3">
                                        <label class="form-label">Question Image</label>
                                        @if (!string.IsNullOrEmpty(question.ImagePath))
                                        {
                                            <div class="mb-2">
                                                <img src="@QuestionImageService.GetImageUrl(question.ImagePath)" alt="Question Image" class="img-thumbnail w-100" style="max-height: 200px; object-fit: cover;" />
                                                <div class="mt-2">
                                                    <button type="button" class="btn btn-3d btn-3d-danger" @onclick="() => RemoveQuestionImageAsync(question)" title="Remove Question Image">Remove Image</button>
                                                </div>
                                            </div>
                                        }
                                        <FileUpload CurrentFile="@GetQuestionImageFile(question)"
                                                   OnFileChanged="@(file => OnQuestionImageFileChanged(question, file))"
                                                   AcceptedFileTypes="image/*"
                                                   MaxFileSize="10 * 1024 * 1024"
                                                   UploadText="Click or drag question image to upload"
                                                   UploadHint="Supports JPG, PNG, GIF up to 10MB" />
                                    </div>

                                    <!-- Question Audio Upload Section -->
                                    <div class="col-md-6 mb-3">
                                        <label class="form-label">Question Audio (MP3)</label>
                                        @if (!string.IsNullOrEmpty(question.AudioPath))
                                        {
                                            <div class="mb-2">
                                                @if (question.AudioPath.EndsWith(".mp3", StringComparison.OrdinalIgnoreCase))
                                                {
                                                    <audio controls class="w-100">
                                                        <source src="@QuestionAudioService.GetAudioUrl(question.AudioPath)" type="audio/mpeg" />
                                                        Your browser does not support the audio element.
                                                    </audio>
                                                }
                                                else
                                                {
                                                    <span>Audio file: @question.AudioPath</span>
                                                }
                                                <div class="mt-2">
                                                    <button type="button" class="btn btn-3d btn-3d-danger" @onclick="() => RemoveQuestionAudioAsync(question)" title="Remove Question Audio">Remove Audio</button>
                                                </div>
                                            </div>
                                        }
                                        <FileUpload CurrentFile="@GetQuestionAudioFile(question)"
                                                   OnFileChanged="@(file => OnQuestionAudioFileChanged(question, file))"
                                                   AcceptedFileTypes=".mp3,audio/*"
                                                   MaxFileSize="20 * 1024 * 1024"
                                                   UploadText="Click or drag MP3 file to upload"
                                                   UploadHint="Supports MP3 files up to 20MB" />
                                    </div>
                                </div>
                            </div>

                            <!-- Right side: Question Type, Options, and Answer Explanation -->
                            <div class="col-md-6">
                                <!-- Question Type Selection -->
                                <div class="mb-3">
                                    <h6>Question Type</h6>
                                    <div class="d-flex gap-2">
                                        <button type="button" class="btn btn-3d @(question.IsTextAnswer ? "btn-3d-primary" : "btn-3d-success") btn-sm" @onclick="() => { question.IsTextAnswer = false; OnQuestionTypeChanged(question); }">
                                            Multiple Choice
                                        </button>
                                        <button type="button" class="btn btn-3d @(question.IsTextAnswer ? "btn-3d-success" : "btn-3d-primary") btn-sm" @onclick="() => { question.IsTextAnswer = true; OnQuestionTypeChanged(question); }">
                                            Text Input
                                        </button>
                                    </div>
                                </div>

                                @if (!question.IsTextAnswer)
                                {
                                    <!-- Multiple Choice Options -->
                                    <h6>Options</h6>
                                    <ol>
                                        @foreach (var o in question.Options)
                                        {
                                            var optionIndex = question.Options.IndexOf(o);
                                            <li class="p-2 mb-2">
                                                <div class="input-group @(o.IsCorrect ? "correct-option" : "") @(ReferenceEquals(_selectedOption, o) ? "selected-option" : "")" @onclick="() => SelectOption(question, o)">
                                                    <div class="input-group-text custom-input-group-text toggle-checkbox">
                                                        <input type="checkbox" class="form-check-input mt-0" checked="@o.IsCorrect" @onchange="args => SetOptionAsCorrectAnswer(question, o)" style="display:none;" id="option_@o.GetHashCode()" />
                                                        <label for="option_@o.GetHashCode()" class="toggle-label m-0 d-flex align-items-center justify-content-center" style="min-width: 20px;">
                                                            @if (o.IsCorrect)
                                                            {
                                                                <span class="material-symbols-outlined">check</span>
                                                            }
                                                            else
                                                            {
                                                                <span class="material-symbols-outlined">close</span>
                                                            }
                                                        </label>
                                                    </div>
                                                    <input type="text" class="form-control no-border-radius" aria-label="Text input with checkbox" @bind="o.Text"/>
                                                    <button type="button" class="btn btn-3d btn-3d-danger option-delete-btn @(ReferenceEquals(_selectedOption, o) ? "selected-delete-btn" : "")" @onclick="() => DeleteOptionAsync(question, o)">X</button>
                                                </div>
                                            </li>
                                        }
                                    </ol>
                                    <div class="d-flex justify-content-end">
                                        <button type="button" class="btn btn-3d btn-3d-primary btn-sm" @onclick="() => AddOptionToQuestion(question)">+ Add Option</button>
                                    </div>
                                }
                                else
                                {
                                    <!-- Text Input Answer -->
                                    <h6>Possible Correct Answers</h6>
                                    <div class="mb-3">
                                        @if (question.TextAnswers != null)
                                        {
                                            @foreach (var textAnswer in question.TextAnswers.ToList()) // Use ToList() to avoid collection modification during enumeration
                                            {
                                                var textAnswerIndex = question.TextAnswers.IndexOf(textAnswer);
                                                <div class="input-group mb-2">
                                                    <input type="text" class="form-control" placeholder="Enter a correct answer" @bind="textAnswer.Text"/>
                                                    <button type="button" class="btn btn-3d btn-3d-danger" @onclick="() => question.TextAnswers.Remove(textAnswer)">X</button>
                                                </div>
                                            }
                                        }
                                        <button type="button" class="btn btn-3d btn-3d-primary" @onclick="() => question.TextAnswers.Add(new TextAnswerDto())">+ Add Correct Answer</button>
                                    </div>
                                }

                                <!-- Answer Explanation Section -->
                                <div class="mb-3">
                                    <label class="form-label">Answer Explanation</label>
                                    <input type="text" class="form-control form-control-centered" @bind="question.AnswerExplanation" placeholder="Enter explanation for the correct answer" style="font-size: 1.1rem; letter-spacing: 0.1rem;" />
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            }
        </div>

        <!-- Navigation buttons for the whole slider -->
        @if (CurrentCardIndex > 0)
        {
            <button type="button" class="nav-btn prev-btn" @onclick="GoToPrevCard">❮</button>
        }

        @if (CurrentCardIndex < TotalCards - 1)
        {
            <button type="button" class="nav-btn next-btn" @onclick="GoToNextCard">❯</button>
        }
    </div>
</EditForm>

<!-- Add Question Button positioned on the right side -->
<button type="button" class="add-question-btn" @onclick="AddNewQuestion" title="Add Question">
    +
</button>

<!-- Save Questions Button positioned at the bottom like the Add Question button -->
<button type="button" class="save-quiz-btn" title="Save Questions" @onclick="HandleSaveQuestionsClick">
    Save Questions
</button>

@code {
    [Parameter]
    public int? QuestionId { get; set; }

    private bool _isEditCase => QuestionId.HasValue && QuestionId.Value != 0;
    private List<QuestionDto> _questions = new();
    private IBrowserFile? _selectedImageFile;
    private IBrowserFile? _selectedAudioFile;
    private int CurrentCardIndex { get; set; } = 0;
    private OptionDto? _selectedOption = null;

    private int TotalCards => _questions.Count;

    protected override async Task OnInitializedAsync()
    {
        if (_isEditCase)
        {
            // Fetch question from API
            AppState.ShowLoader("Loading Question");
            try
            {
                var response = await QuizApi.GetQuestionByIdAsync(QuestionId.Value);
                if (response.IsSuccess && response.Data != null)
                {
                    _questions.Add(response.Data);
                }
                else
                {
                    await ShowAlertAsync(response.ErrorMessage ?? "Failed to load question");
                    NavigationManager.NavigateTo("/teacher/manage-questions");
                    return;
                }
            }
            catch (Exception ex)
            {
                await ShowAlertAsync($"Error loading question: {ex.Message}");
                NavigationManager.NavigateTo("/teacher/manage-questions");
                return;
            }
            finally
            {
                AppState.HideLoader();
            }
        }
        else
        {
            // Initialize with default values for a new question
            _questions.Add(new QuestionDto
            {
                Options = new List<OptionDto> { new OptionDto(), new OptionDto() },
                TextAnswers = new List<TextAnswerDto>(),
                IsTextAnswer = false
            });
        }
    }

    private void SetOptionAsCorrectAnswer(QuestionDto q, OptionDto o)
    {
        // If the clicked option is currently correct, toggle it off (uncheck)
        if (o.IsCorrect)
        {
            o.IsCorrect = false;
        }
        else
        {
            // If the clicked option is not correct, make it correct and uncheck all others
            foreach (var option in q.Options)
            {
                option.IsCorrect = false;
            }
            o.IsCorrect = true;
        }
    }

    private void SelectOption(QuestionDto question, OptionDto option)
    {
        // Toggle selection: if the same option is clicked again, deselect it
        if (_selectedOption == option)
        {
            _selectedOption = null;
        }
        else
        {
            _selectedOption = option;
        }
        StateHasChanged();
    }

    private void AddOptionToQuestion(QuestionDto question)
    {
        question.Options.Add(new OptionDto());
    }

    private void OnQuestionTypeChanged(QuestionDto question)
    {
        if (question.IsTextAnswer)
        {
            // Clear options when switching to text answer
            question.Options.Clear();
        }
        else
        {
            // Clear text answers when switching to multiple choice
            question.TextAnswers.Clear();
        }
    }

    private async Task DeleteOptionAsync(QuestionDto question, OptionDto option)
    {
        bool confirmed = await ShowConfirmAsync("Are you sure you want to delete this option?");
        if (confirmed)
        {
            // If the option exists in the database (has an ID), delete it from the database
            if (option.Id != 0)
            {
                AppState.ShowLoader("Deleting option from database...");
                var response = await QuizApi.DeleteOptionAsync(option.Id);
                AppState.HideLoader();

                if (!response.IsSuccess)
                {
                    await ShowAlertAsync($"Failed to delete option from database: {response.ErrorMessage}");
                    return;
                }
            }

            // Remove from the local collection
            question.Options.Remove(option);
        }
    }

    private async Task DeleteQuestionAsync(QuestionDto question)
    {
        bool confirmed = await ShowConfirmAsync("Are you sure you want to delete this question? This will also delete all options for this question.");
        if (confirmed)
        {
            // If the question exists in the database (has an ID), delete it from the database
            // This will also delete all associated options due to foreign key constraints in the backend
            if (question.Id != 0)
            {
                AppState.ShowLoader("Deleting question and its options from database...");
                var response = await QuizApi.DeleteQuestionAsync(question.Id);
                AppState.HideLoader();

                if (!response.IsSuccess)
                {
                    await ShowAlertAsync($"Failed to delete question from database: {response.ErrorMessage}");
                    return;
                }
            }

            _questions.Remove(question);
            // Adjust current card index if needed
            if (CurrentCardIndex >= _questions.Count && _questions.Count > 0)
            {
                CurrentCardIndex = _questions.Count - 1;
            }
            else if (_questions.Count == 0)
            {
                _questions.Add(new QuestionDto
                {
                    Options = new List<OptionDto> { new OptionDto(), new OptionDto() },
                    TextAnswers = new List<TextAnswerDto>(),
                    IsTextAnswer = false
                });
                CurrentCardIndex = 0;
            }
        }
    }

    private void AddNewQuestion()
    {
        _questions.Add(new QuestionDto
        {
            Options = new List<OptionDto> { new OptionDto(), new OptionDto() },
            TextAnswers = new List<TextAnswerDto>(),
            IsTextAnswer = false
        });
        StateHasChanged();
    }

    private async Task HandleSaveQuestionsClick()
    {
        // Basic validation for all questions
        for (int i = 0; i < _questions.Count; i++)
        {
            var question = _questions[i];

            if (string.IsNullOrWhiteSpace(question.Text))
            {
                await ShowAlertAsync($"Question {i + 1} text is required.");
                return;
            }

            if (!question.IsTextAnswer && question.Options.Count == 0)
            {
                await ShowAlertAsync($"Question {i + 1} requires at least one option for multiple choice questions.");
                return;
            }

            if (!question.IsTextAnswer && !question.Options.Any(o => o.IsCorrect))
            {
                await ShowAlertAsync($"Question {i + 1} must have at least one option marked as correct.");
                return;
            }
        }

        AppState.ShowLoader("Saving questions");

        try
        {
            bool allSaved = true;
            List<string> errors = new();

            foreach (var question in _questions)
            {
                QuizApiResponse response;
                if (question.Id != 0) // Existing question
                {
                    response = await QuizApi.UpdateQuestionAsync(question.Id, question);
                }
                else // New question
                {
                    response = await QuizApi.SaveQuestionAsync(question);
                }

                if (!response.IsSuccess)
                {
                    allSaved = false;
                    errors.Add(response.ErrorMessage ?? "Failed to save question");
                }
            }

            if (allSaved)
            {
                AppState.ShowAlert("All questions saved successfully", AlertType.Success);
                NavigationManager.NavigateTo("/teacher/manage-questions");
            }
            else
            {
                await ShowAlertAsync(string.Join("\n", errors));
            }
        }
        catch (Exception ex)
        {
            await ShowAlertAsync($"Error saving questions: {ex.Message}");
        }
        finally
        {
            AppState.HideLoader();
        }
    }

    private async Task ShowAlertAsync(string message, string title = "Error") =>
        await JsRuntime.InvokeVoidAsync("alert", $"{title}\n{message}");

    private async Task<bool> ShowConfirmAsync(string message) =>
        await JsRuntime.InvokeAsync<bool>("confirm", message);

    private IBrowserFile? GetQuestionImageFile(QuestionDto question)
    {
        if (_questionImageFiles.ContainsKey(question))
        {
            return _questionImageFiles[question];
        }
        return null;
    }

    private IBrowserFile? GetQuestionAudioFile(QuestionDto question)
    {
        if (_questionAudioFiles.ContainsKey(question))
        {
            return _questionAudioFiles[question];
        }
        return null;
    }

    private async Task OnQuestionImageFileChanged(QuestionDto question, IBrowserFile file)
    {
        _questionImageFiles[question] = file;
        StateHasChanged();
    }

    private async Task OnQuestionAudioFileChanged(QuestionDto question, IBrowserFile file)
    {
        _questionAudioFiles[question] = file;
        StateHasChanged();
    }

    private async Task RemoveQuestionImageAsync(QuestionDto question)
    {
        if (question.Id == 0) // New question, not saved yet
        {
            question.ImagePath = null;
            if (_questionImageFiles.ContainsKey(question))
            {
                _questionImageFiles.Remove(question);
            }
        }
        else // Saved question
        {
            var result = await QuestionImageService.RemoveQuestionImageAsync(question.Id);
            if (result.IsSuccess)
            {
                question.ImagePath = null;
            }
            else
            {
                await ShowAlertAsync("Failed to remove image: " + result.ErrorMessage);
            }
        }
    }

    private async Task RemoveQuestionAudioAsync(QuestionDto question)
    {
        if (question.Id == 0) // New question, not saved yet
        {
            question.AudioPath = null;
            if (_questionAudioFiles.ContainsKey(question))
            {
                _questionAudioFiles.Remove(question);
            }
        }
        else // Saved question
        {
            var result = await QuestionAudioService.RemoveQuestionAudioAsync(question.Id);
            if (result.IsSuccess)
            {
                question.AudioPath = null;
            }
            else
            {
                await ShowAlertAsync("Failed to remove audio: " + result.ErrorMessage);
            }
        }
    }

    private Dictionary<QuestionDto, IBrowserFile?> _questionImageFiles = new();
    private Dictionary<QuestionDto, IBrowserFile?> _questionAudioFiles = new();

    private void GoToCard(int index)
    {
        CurrentCardIndex = index;
    }

    private void GoToPrevCard()
    {
        if (CurrentCardIndex > 0)
            CurrentCardIndex--;
    }

    private void GoToNextCard()
    {
        if (CurrentCardIndex < TotalCards - 1)
            CurrentCardIndex++;
    }
}